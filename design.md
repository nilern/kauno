# Kauno Design

## Language Overview

Dynamically typed functional-first language with

* Modules
    - Recursive modules
* First-class functions with
    - Arity and parameter type checking (mostly to facilitate use as multimethod methods)
* Multimethods with
    - Type parameters (`pure{T = Option}()`) (CLOS (eql specializers), Julia (`Type{Int}`))
    - Templated methods (`forall T . get(v : Array{T}, i : USize)`) (Julia)
* Dynamic type classes (built on top of multimethods)
* Types with
    - Both composite and bits types (Julia)
    - Access-controllable (via modules) constructors and field accessors (Scheme)
    - Data inlining (Project Valhalla)
    - Optional indexed final field (C flexible struct member)
* Multiple (return) values (Scheme, Lua)
* Extensible effects / delimited continuations (Racket)
* Hygienic macros (Scheme)

no

* Classical or prototypical OO (complecting)
* Implicit conversions (bug-inducing)
* Accepting more/less arguments than arity (bug-inducing)
* Arity overloading or vararg functions (bug-inducing, possibly slow)
* Method or field access by name from anywhere (abstraction-breaking, slow)
* Inheritance from concrete types (abstraction-breaking, prevents data inlining)
* Forward declarations (archaic and annoying)
* Subtyping and overriding

## Implementation Overview

* Bytecode VM
    - Bytecode more like Self than Lua 5
    - Self-hosted bytecode compiler
* Simple self-hosted method JIT
* AST interpreter for bootstrapping

## Grammar

    expr ::= 'fn' '(' (param (',' param)*)? '->' expr
           | call

    call ::= callee '(' (expr (',' expr)*)? ')'
           | callee

    callee ::= '(' expr ')'
             | VAR
             | const

    const ::= INT

    param ::= VAR (':' expr)

### LL(1) Grammar

    expr ::= 'fn' '(' (param (',' param)*)? '->' expr
           | call

    call ::= callee ('(' (expr (',' expr)*)? ')')?

    callee ::= '(' expr ')'
             | VAR
             | const

    const ::= INT

    param ::= VAR (':' expr)

## Templates

A template of arity *n* is a memoized function from type sequences of length *n* to values.

## Dispatchers

A dispatcher of arity *n* is a mapping from type sequences of length *n* to values. The dispatcher
entries may also be templates (whose domains can be distinct from the dispatcher domain).

Even with templated entries, type sequence keys must not overlap. In theory this means the keys
don't overlap when the templates are expanded out by applying them to all possible type sequences.
In practice applying an entry template to two distinct inputs must produce outputs with distinct keys
and it should be possible to use techniques from static universal type instantiationand unification
to ensure templated entries do not overlap with each other or nontemplated entries.

## Types

    record Type {
        align : USize;
        minSize : USize;
        isBits : Bool;
        mutable : Bool;
        inlineable : Bool;
        indexed fields : Field;
    }

`mutable` is true if there are mutable fields or `isBits` and the bits are mutable
(e.g. an opaque FFI struct in disguise).

`inlineable` is true if `mutable` is false (updates could not be propagated to all copies efficiently)
and there are no indexed (instances differ in size) fields.

Any single field can be indexed, but the runtime lays it out last. Fields will be otherwise reordered
for efficiency too (minimizing alignment padding), except for FFI where the foreign layout obviously
has to be matched exactly. For parameterized types the layout order may differ by instance type but
the order of `fields` will not.

    record Field {
        type : Type;
        offset : USize;
        size : USize;
        inlined : Bool;
        mutable : Bool;
        indexed : Bool;
    };

`type` is null (and `inlined` false) for polymorphic fields.

Otherwise `size` and `inlined` are just copied from `type` to reduce indirection.

While mutable types may not be inlined, types may be inlined into mutable fields.

## Constructors

Constructors are autogenerated normal functions whose parameters correspond to the fields and whose
domain is the sequence of field types.

## Accessors

Instead of by name, fields are accessed via accessor values, which can be module-public or private
like any value.

    record FieldAccessor {
        type : Type
        index : USize;
    }

Immutable fields may be read and updated (allocating a new updated value). Mutable fields may
also be set in place. Indexed fields require the index in addition to the accessor and accessee.

Like calls, field accesses will be inline cached. This is simple since types, fields and accessors are
all immutable.

## Parameterized Types

A parameterized type (= type constructor) is a template to concrete types.

Its constructor is a multimethod with a single method templated with the type constructor parameters.

Field accessors for parameterized types normal acessors; the accessee is of an instantiated type
and that type contains the specialized `Field`s.
